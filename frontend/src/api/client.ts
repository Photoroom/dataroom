/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * DataRoom API
 * Store training images at scale.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AttributeField,
  Count,
  Dataset,
  DatasetCreate,
  DatasetPreviewImages,
  DatasetUpdateImages,
  DatasetUpdateImagesResponse,
  DatasetsListParams,
  ImageIdsWithTagNames,
  ImagesAggregateCreateParams,
  ImagesBucketCreateParams,
  ImagesCountRetrieveParams,
  ImagesListParams,
  ImagesRandomRetrieveParams,
  ImagesRelatedListParams,
  ImagesRetrieveParams,
  ImagesSimilarListParams,
  ImagesSimilarToFileCreateBody,
  ImagesSimilarToFileCreateParams,
  ImagesSimilarToTextCreateParams,
  ImagesSimilarToVectorCreateParams,
  LatentType,
  OSImage,
  OSImageCreate,
  OSImageSegmentation,
  OSImageUpdate,
  PaginatedDatasetList,
  PaginatedOSImage,
  PaginatedTagList,
  PaginatedTokenList,
  PatchedDataset,
  PatchedTag,
  PatchedToken,
  Queue,
  RelatedOSImage,
  SimilarOSImage,
  SimilarToText,
  SimilarToVector,
  StatsImageAspectRatioFractionsRetrieve200,
  StatsImageSourcesRetrieve200,
  Tag,
  TagImagesResponse,
  TagsListParams,
  Token,
  TokensListParams,
  Totals
} from './client.schemas';

import { axiosInstance } from './axios';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export const datasetsList = (
    params?: DatasetsListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PaginatedDatasetList>(
      {url: `/api/datasets/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getDatasetsListQueryKey = (params?: DatasetsListParams,) => {
    return [`/api/datasets/`, ...(params ? [params]: [])] as const;
    }

    
export const getDatasetsListQueryOptions = <TData = Awaited<ReturnType<typeof datasetsList>>, TError = unknown>(params?: DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDatasetsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof datasetsList>>> = ({ signal }) => datasetsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof datasetsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DatasetsListQueryResult = NonNullable<Awaited<ReturnType<typeof datasetsList>>>
export type DatasetsListQueryError = unknown


export function useDatasetsList<TData = Awaited<ReturnType<typeof datasetsList>>, TError = unknown>(
 params: undefined |  DatasetsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof datasetsList>>,
          TError,
          Awaited<ReturnType<typeof datasetsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatasetsList<TData = Awaited<ReturnType<typeof datasetsList>>, TError = unknown>(
 params?: DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof datasetsList>>,
          TError,
          Awaited<ReturnType<typeof datasetsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatasetsList<TData = Awaited<ReturnType<typeof datasetsList>>, TError = unknown>(
 params?: DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDatasetsList<TData = Awaited<ReturnType<typeof datasetsList>>, TError = unknown>(
 params?: DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDatasetsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const datasetsCreate = (
    datasetCreate: NonReadonly<DatasetCreate>,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<DatasetCreate>(
      {url: `/api/datasets/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: datasetCreate, signal
    },
      options);
    }
  


export const getDatasetsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsCreate>>, TError,{data: NonReadonly<DatasetCreate>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsCreate>>, TError,{data: NonReadonly<DatasetCreate>}, TContext> => {

const mutationKey = ['datasetsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsCreate>>, {data: NonReadonly<DatasetCreate>}> = (props) => {
          const {data} = props ?? {};

          return  datasetsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsCreate>>>
    export type DatasetsCreateMutationBody = NonReadonly<DatasetCreate>
    export type DatasetsCreateMutationError = unknown

    export const useDatasetsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsCreate>>, TError,{data: NonReadonly<DatasetCreate>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsCreate>>,
        TError,
        {data: NonReadonly<DatasetCreate>},
        TContext
      > => {

      const mutationOptions = getDatasetsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsRetrieve = (
    slugVersion: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Dataset>(
      {url: `/api/datasets/${slugVersion}/`, method: 'GET', signal
    },
      options);
    }
  

export const getDatasetsRetrieveQueryKey = (slugVersion?: string,) => {
    return [`/api/datasets/${slugVersion}/`] as const;
    }

    
export const getDatasetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof datasetsRetrieve>>, TError = unknown>(slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDatasetsRetrieveQueryKey(slugVersion);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof datasetsRetrieve>>> = ({ signal }) => datasetsRetrieve(slugVersion, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slugVersion),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof datasetsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DatasetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof datasetsRetrieve>>>
export type DatasetsRetrieveQueryError = unknown


export function useDatasetsRetrieve<TData = Awaited<ReturnType<typeof datasetsRetrieve>>, TError = unknown>(
 slugVersion: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof datasetsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof datasetsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatasetsRetrieve<TData = Awaited<ReturnType<typeof datasetsRetrieve>>, TError = unknown>(
 slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof datasetsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof datasetsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatasetsRetrieve<TData = Awaited<ReturnType<typeof datasetsRetrieve>>, TError = unknown>(
 slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDatasetsRetrieve<TData = Awaited<ReturnType<typeof datasetsRetrieve>>, TError = unknown>(
 slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDatasetsRetrieveQueryOptions(slugVersion,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const datasetsUpdate = (
    slugVersion: string,
    dataset: NonReadonly<Dataset>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<Dataset>(
      {url: `/api/datasets/${slugVersion}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: dataset
    },
      options);
    }
  


export const getDatasetsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsUpdate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsUpdate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext> => {

const mutationKey = ['datasetsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsUpdate>>, {slugVersion: string;data: NonReadonly<Dataset>}> = (props) => {
          const {slugVersion,data} = props ?? {};

          return  datasetsUpdate(slugVersion,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsUpdate>>>
    export type DatasetsUpdateMutationBody = NonReadonly<Dataset>
    export type DatasetsUpdateMutationError = unknown

    export const useDatasetsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsUpdate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsUpdate>>,
        TError,
        {slugVersion: string;data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getDatasetsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsPartialUpdate = (
    slugVersion: string,
    patchedDataset: NonReadonly<PatchedDataset>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<Dataset>(
      {url: `/api/datasets/${slugVersion}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedDataset
    },
      options);
    }
  


export const getDatasetsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsPartialUpdate>>, TError,{slugVersion: string;data: NonReadonly<PatchedDataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsPartialUpdate>>, TError,{slugVersion: string;data: NonReadonly<PatchedDataset>}, TContext> => {

const mutationKey = ['datasetsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsPartialUpdate>>, {slugVersion: string;data: NonReadonly<PatchedDataset>}> = (props) => {
          const {slugVersion,data} = props ?? {};

          return  datasetsPartialUpdate(slugVersion,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsPartialUpdate>>>
    export type DatasetsPartialUpdateMutationBody = NonReadonly<PatchedDataset>
    export type DatasetsPartialUpdateMutationError = unknown

    export const useDatasetsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsPartialUpdate>>, TError,{slugVersion: string;data: NonReadonly<PatchedDataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsPartialUpdate>>,
        TError,
        {slugVersion: string;data: NonReadonly<PatchedDataset>},
        TContext
      > => {

      const mutationOptions = getDatasetsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsDestroy = (
    slugVersion: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/datasets/${slugVersion}/`, method: 'DELETE'
    },
      options);
    }
  


export const getDatasetsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsDestroy>>, TError,{slugVersion: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsDestroy>>, TError,{slugVersion: string}, TContext> => {

const mutationKey = ['datasetsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsDestroy>>, {slugVersion: string}> = (props) => {
          const {slugVersion} = props ?? {};

          return  datasetsDestroy(slugVersion,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsDestroy>>>
    
    export type DatasetsDestroyMutationError = unknown

    export const useDatasetsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsDestroy>>, TError,{slugVersion: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsDestroy>>,
        TError,
        {slugVersion: string},
        TContext
      > => {

      const mutationOptions = getDatasetsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsFreezeCreate = (
    slugVersion: string,
    dataset: NonReadonly<Dataset>,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Dataset>(
      {url: `/api/datasets/${slugVersion}/freeze/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: dataset, signal
    },
      options);
    }
  


export const getDatasetsFreezeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsFreezeCreate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsFreezeCreate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext> => {

const mutationKey = ['datasetsFreezeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsFreezeCreate>>, {slugVersion: string;data: NonReadonly<Dataset>}> = (props) => {
          const {slugVersion,data} = props ?? {};

          return  datasetsFreezeCreate(slugVersion,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsFreezeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsFreezeCreate>>>
    export type DatasetsFreezeCreateMutationBody = NonReadonly<Dataset>
    export type DatasetsFreezeCreateMutationError = unknown

    export const useDatasetsFreezeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsFreezeCreate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsFreezeCreate>>,
        TError,
        {slugVersion: string;data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getDatasetsFreezeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsImagesRetrieve = (
    slugVersion: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<DatasetPreviewImages>(
      {url: `/api/datasets/${slugVersion}/images/`, method: 'GET', signal
    },
      options);
    }
  

export const getDatasetsImagesRetrieveQueryKey = (slugVersion?: string,) => {
    return [`/api/datasets/${slugVersion}/images/`] as const;
    }

    
export const getDatasetsImagesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError = unknown>(slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDatasetsImagesRetrieveQueryKey(slugVersion);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof datasetsImagesRetrieve>>> = ({ signal }) => datasetsImagesRetrieve(slugVersion, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slugVersion),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DatasetsImagesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof datasetsImagesRetrieve>>>
export type DatasetsImagesRetrieveQueryError = unknown


export function useDatasetsImagesRetrieve<TData = Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError = unknown>(
 slugVersion: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof datasetsImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof datasetsImagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatasetsImagesRetrieve<TData = Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError = unknown>(
 slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof datasetsImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof datasetsImagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatasetsImagesRetrieve<TData = Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError = unknown>(
 slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDatasetsImagesRetrieve<TData = Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError = unknown>(
 slugVersion: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof datasetsImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDatasetsImagesRetrieveQueryOptions(slugVersion,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const datasetsImagesCreate = (
    slugVersion: string,
    datasetUpdateImages: DatasetUpdateImages,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<DatasetUpdateImagesResponse>(
      {url: `/api/datasets/${slugVersion}/images/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: datasetUpdateImages, signal
    },
      options);
    }
  


export const getDatasetsImagesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsImagesCreate>>, TError,{slugVersion: string;data: DatasetUpdateImages}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsImagesCreate>>, TError,{slugVersion: string;data: DatasetUpdateImages}, TContext> => {

const mutationKey = ['datasetsImagesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsImagesCreate>>, {slugVersion: string;data: DatasetUpdateImages}> = (props) => {
          const {slugVersion,data} = props ?? {};

          return  datasetsImagesCreate(slugVersion,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsImagesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsImagesCreate>>>
    export type DatasetsImagesCreateMutationBody = DatasetUpdateImages
    export type DatasetsImagesCreateMutationError = unknown

    export const useDatasetsImagesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsImagesCreate>>, TError,{slugVersion: string;data: DatasetUpdateImages}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsImagesCreate>>,
        TError,
        {slugVersion: string;data: DatasetUpdateImages},
        TContext
      > => {

      const mutationOptions = getDatasetsImagesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsImagesDestroy = (
    slugVersion: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/datasets/${slugVersion}/images/`, method: 'DELETE'
    },
      options);
    }
  


export const getDatasetsImagesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsImagesDestroy>>, TError,{slugVersion: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsImagesDestroy>>, TError,{slugVersion: string}, TContext> => {

const mutationKey = ['datasetsImagesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsImagesDestroy>>, {slugVersion: string}> = (props) => {
          const {slugVersion} = props ?? {};

          return  datasetsImagesDestroy(slugVersion,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsImagesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsImagesDestroy>>>
    
    export type DatasetsImagesDestroyMutationError = unknown

    export const useDatasetsImagesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsImagesDestroy>>, TError,{slugVersion: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsImagesDestroy>>,
        TError,
        {slugVersion: string},
        TContext
      > => {

      const mutationOptions = getDatasetsImagesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const datasetsUnfreezeCreate = (
    slugVersion: string,
    dataset: NonReadonly<Dataset>,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Dataset>(
      {url: `/api/datasets/${slugVersion}/unfreeze/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: dataset, signal
    },
      options);
    }
  


export const getDatasetsUnfreezeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsUnfreezeCreate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof datasetsUnfreezeCreate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext> => {

const mutationKey = ['datasetsUnfreezeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof datasetsUnfreezeCreate>>, {slugVersion: string;data: NonReadonly<Dataset>}> = (props) => {
          const {slugVersion,data} = props ?? {};

          return  datasetsUnfreezeCreate(slugVersion,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DatasetsUnfreezeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof datasetsUnfreezeCreate>>>
    export type DatasetsUnfreezeCreateMutationBody = NonReadonly<Dataset>
    export type DatasetsUnfreezeCreateMutationError = unknown

    export const useDatasetsUnfreezeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof datasetsUnfreezeCreate>>, TError,{slugVersion: string;data: NonReadonly<Dataset>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof datasetsUnfreezeCreate>>,
        TError,
        {slugVersion: string;data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getDatasetsUnfreezeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesList = (
    params?: ImagesListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PaginatedOSImage>(
      {url: `/api/images/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getImagesListQueryKey = (params?: ImagesListParams,) => {
    return [`/api/images/`, ...(params ? [params]: [])] as const;
    }

    
export const getImagesListQueryOptions = <TData = Awaited<ReturnType<typeof imagesList>>, TError = unknown>(params?: ImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesList>>> = ({ signal }) => imagesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesListQueryResult = NonNullable<Awaited<ReturnType<typeof imagesList>>>
export type ImagesListQueryError = unknown


export function useImagesList<TData = Awaited<ReturnType<typeof imagesList>>, TError = unknown>(
 params: undefined |  ImagesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesList>>,
          TError,
          Awaited<ReturnType<typeof imagesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesList<TData = Awaited<ReturnType<typeof imagesList>>, TError = unknown>(
 params?: ImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesList>>,
          TError,
          Awaited<ReturnType<typeof imagesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesList<TData = Awaited<ReturnType<typeof imagesList>>, TError = unknown>(
 params?: ImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesList<TData = Awaited<ReturnType<typeof imagesList>>, TError = unknown>(
 params?: ImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesCreate = (
    oSImageCreate: OSImageCreate,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: oSImageCreate, signal
    },
      options);
    }
  


export const getImagesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesCreate>>, TError,{data: OSImageCreate}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesCreate>>, TError,{data: OSImageCreate}, TContext> => {

const mutationKey = ['imagesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesCreate>>, {data: OSImageCreate}> = (props) => {
          const {data} = props ?? {};

          return  imagesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesCreate>>>
    export type ImagesCreateMutationBody = OSImageCreate
    export type ImagesCreateMutationError = unknown

    export const useImagesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesCreate>>, TError,{data: OSImageCreate}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesCreate>>,
        TError,
        {data: OSImageCreate},
        TContext
      > => {

      const mutationOptions = getImagesCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesRetrieve = (
    id: string,
    params?: ImagesRetrieveParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<OSImage>(
      {url: `/api/images/${id}/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getImagesRetrieveQueryKey = (id?: string,
    params?: ImagesRetrieveParams,) => {
    return [`/api/images/${id}/`, ...(params ? [params]: [])] as const;
    }

    
export const getImagesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof imagesRetrieve>>, TError = unknown>(id: string,
    params?: ImagesRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesRetrieveQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesRetrieve>>> = ({ signal }) => imagesRetrieve(id,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof imagesRetrieve>>>
export type ImagesRetrieveQueryError = unknown


export function useImagesRetrieve<TData = Awaited<ReturnType<typeof imagesRetrieve>>, TError = unknown>(
 id: string,
    params: undefined |  ImagesRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesRetrieve<TData = Awaited<ReturnType<typeof imagesRetrieve>>, TError = unknown>(
 id: string,
    params?: ImagesRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesRetrieve<TData = Awaited<ReturnType<typeof imagesRetrieve>>, TError = unknown>(
 id: string,
    params?: ImagesRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesRetrieve<TData = Awaited<ReturnType<typeof imagesRetrieve>>, TError = unknown>(
 id: string,
    params?: ImagesRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesRetrieveQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesUpdate = (
    id: string,
    oSImageUpdate: OSImageUpdate,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: oSImageUpdate
    },
      options);
    }
  


export const getImagesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesUpdate>>, TError,{id: string;data: OSImageUpdate}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesUpdate>>, TError,{id: string;data: OSImageUpdate}, TContext> => {

const mutationKey = ['imagesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesUpdate>>, {id: string;data: OSImageUpdate}> = (props) => {
          const {id,data} = props ?? {};

          return  imagesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesUpdate>>>
    export type ImagesUpdateMutationBody = OSImageUpdate
    export type ImagesUpdateMutationError = unknown

    export const useImagesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesUpdate>>, TError,{id: string;data: OSImageUpdate}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesUpdate>>,
        TError,
        {id: string;data: OSImageUpdate},
        TContext
      > => {

      const mutationOptions = getImagesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesDestroy = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getImagesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['imagesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  imagesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof imagesDestroy>>>
    
    export type ImagesDestroyMutationError = unknown

    export const useImagesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getImagesDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesAddAttributesUpdate = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/${id}/add_attributes/`, method: 'PUT'
    },
      options);
    }
  


export const getImagesAddAttributesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesAddAttributesUpdate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesAddAttributesUpdate>>, TError,{id: string}, TContext> => {

const mutationKey = ['imagesAddAttributesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesAddAttributesUpdate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  imagesAddAttributesUpdate(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesAddAttributesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesAddAttributesUpdate>>>
    
    export type ImagesAddAttributesUpdateMutationError = unknown

    export const useImagesAddAttributesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesAddAttributesUpdate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesAddAttributesUpdate>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getImagesAddAttributesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesDeleteLatentCreate = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/${id}/delete_latent/`, method: 'POST', signal
    },
      options);
    }
  


export const getImagesDeleteLatentCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesDeleteLatentCreate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesDeleteLatentCreate>>, TError,{id: string}, TContext> => {

const mutationKey = ['imagesDeleteLatentCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesDeleteLatentCreate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  imagesDeleteLatentCreate(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesDeleteLatentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesDeleteLatentCreate>>>
    
    export type ImagesDeleteLatentCreateMutationError = unknown

    export const useImagesDeleteLatentCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesDeleteLatentCreate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesDeleteLatentCreate>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getImagesDeleteLatentCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesRelatedList = (
    id: string,
    params?: ImagesRelatedListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<RelatedOSImage[]>(
      {url: `/api/images/${id}/related/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getImagesRelatedListQueryKey = (id?: string,
    params?: ImagesRelatedListParams,) => {
    return [`/api/images/${id}/related/`, ...(params ? [params]: [])] as const;
    }

    
export const getImagesRelatedListQueryOptions = <TData = Awaited<ReturnType<typeof imagesRelatedList>>, TError = unknown>(id: string,
    params?: ImagesRelatedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRelatedList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesRelatedListQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesRelatedList>>> = ({ signal }) => imagesRelatedList(id,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesRelatedList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesRelatedListQueryResult = NonNullable<Awaited<ReturnType<typeof imagesRelatedList>>>
export type ImagesRelatedListQueryError = unknown


export function useImagesRelatedList<TData = Awaited<ReturnType<typeof imagesRelatedList>>, TError = unknown>(
 id: string,
    params: undefined |  ImagesRelatedListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRelatedList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesRelatedList>>,
          TError,
          Awaited<ReturnType<typeof imagesRelatedList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesRelatedList<TData = Awaited<ReturnType<typeof imagesRelatedList>>, TError = unknown>(
 id: string,
    params?: ImagesRelatedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRelatedList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesRelatedList>>,
          TError,
          Awaited<ReturnType<typeof imagesRelatedList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesRelatedList<TData = Awaited<ReturnType<typeof imagesRelatedList>>, TError = unknown>(
 id: string,
    params?: ImagesRelatedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRelatedList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesRelatedList<TData = Awaited<ReturnType<typeof imagesRelatedList>>, TError = unknown>(
 id: string,
    params?: ImagesRelatedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRelatedList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesRelatedListQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesSegmentationRetrieve = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<OSImageSegmentation>(
      {url: `/api/images/${id}/segmentation/`, method: 'GET', signal
    },
      options);
    }
  

export const getImagesSegmentationRetrieveQueryKey = (id?: string,) => {
    return [`/api/images/${id}/segmentation/`] as const;
    }

    
export const getImagesSegmentationRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesSegmentationRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>> = ({ signal }) => imagesSegmentationRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesSegmentationRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>>
export type ImagesSegmentationRetrieveQueryError = unknown


export function useImagesSegmentationRetrieve<TData = Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesSegmentationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesSegmentationRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesSegmentationRetrieve<TData = Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesSegmentationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesSegmentationRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesSegmentationRetrieve<TData = Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesSegmentationRetrieve<TData = Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSegmentationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesSegmentationRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesSetLatentCreate = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/${id}/set_latent/`, method: 'POST', signal
    },
      options);
    }
  


export const getImagesSetLatentCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSetLatentCreate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesSetLatentCreate>>, TError,{id: string}, TContext> => {

const mutationKey = ['imagesSetLatentCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesSetLatentCreate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  imagesSetLatentCreate(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesSetLatentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesSetLatentCreate>>>
    
    export type ImagesSetLatentCreateMutationError = unknown

    export const useImagesSetLatentCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSetLatentCreate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesSetLatentCreate>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getImagesSetLatentCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesSimilarList = (
    id: string,
    params?: ImagesSimilarListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SimilarOSImage[]>(
      {url: `/api/images/${id}/similar/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getImagesSimilarListQueryKey = (id?: string,
    params?: ImagesSimilarListParams,) => {
    return [`/api/images/${id}/similar/`, ...(params ? [params]: [])] as const;
    }

    
export const getImagesSimilarListQueryOptions = <TData = Awaited<ReturnType<typeof imagesSimilarList>>, TError = unknown>(id: string,
    params?: ImagesSimilarListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSimilarList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesSimilarListQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesSimilarList>>> = ({ signal }) => imagesSimilarList(id,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesSimilarList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesSimilarListQueryResult = NonNullable<Awaited<ReturnType<typeof imagesSimilarList>>>
export type ImagesSimilarListQueryError = unknown


export function useImagesSimilarList<TData = Awaited<ReturnType<typeof imagesSimilarList>>, TError = unknown>(
 id: string,
    params: undefined |  ImagesSimilarListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSimilarList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesSimilarList>>,
          TError,
          Awaited<ReturnType<typeof imagesSimilarList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesSimilarList<TData = Awaited<ReturnType<typeof imagesSimilarList>>, TError = unknown>(
 id: string,
    params?: ImagesSimilarListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSimilarList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesSimilarList>>,
          TError,
          Awaited<ReturnType<typeof imagesSimilarList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesSimilarList<TData = Awaited<ReturnType<typeof imagesSimilarList>>, TError = unknown>(
 id: string,
    params?: ImagesSimilarListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSimilarList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesSimilarList<TData = Awaited<ReturnType<typeof imagesSimilarList>>, TError = unknown>(
 id: string,
    params?: ImagesSimilarListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesSimilarList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesSimilarListQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesSimilarityCreate = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/${id}/similarity/`, method: 'POST', signal
    },
      options);
    }
  


export const getImagesSimilarityCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarityCreate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarityCreate>>, TError,{id: string}, TContext> => {

const mutationKey = ['imagesSimilarityCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesSimilarityCreate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  imagesSimilarityCreate(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesSimilarityCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesSimilarityCreate>>>
    
    export type ImagesSimilarityCreateMutationError = unknown

    export const useImagesSimilarityCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarityCreate>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesSimilarityCreate>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getImagesSimilarityCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesAddAttributesBulkCreate = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/add_attributes_bulk/`, method: 'POST', signal
    },
      options);
    }
  


export const getImagesAddAttributesBulkCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesAddAttributesBulkCreate>>, TError,void, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesAddAttributesBulkCreate>>, TError,void, TContext> => {

const mutationKey = ['imagesAddAttributesBulkCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesAddAttributesBulkCreate>>, void> = () => {
          

          return  imagesAddAttributesBulkCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesAddAttributesBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesAddAttributesBulkCreate>>>
    
    export type ImagesAddAttributesBulkCreateMutationError = unknown

    export const useImagesAddAttributesBulkCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesAddAttributesBulkCreate>>, TError,void, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesAddAttributesBulkCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getImagesAddAttributesBulkCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesAggregateCreate = (
    params?: ImagesAggregateCreateParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/aggregate/`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getImagesAggregateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesAggregateCreate>>, TError,{params?: ImagesAggregateCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesAggregateCreate>>, TError,{params?: ImagesAggregateCreateParams}, TContext> => {

const mutationKey = ['imagesAggregateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesAggregateCreate>>, {params?: ImagesAggregateCreateParams}> = (props) => {
          const {params} = props ?? {};

          return  imagesAggregateCreate(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesAggregateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesAggregateCreate>>>
    
    export type ImagesAggregateCreateMutationError = unknown

    export const useImagesAggregateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesAggregateCreate>>, TError,{params?: ImagesAggregateCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesAggregateCreate>>,
        TError,
        {params?: ImagesAggregateCreateParams},
        TContext
      > => {

      const mutationOptions = getImagesAggregateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesBucketCreate = (
    params?: ImagesBucketCreateParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/bucket/`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getImagesBucketCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesBucketCreate>>, TError,{params?: ImagesBucketCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesBucketCreate>>, TError,{params?: ImagesBucketCreateParams}, TContext> => {

const mutationKey = ['imagesBucketCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesBucketCreate>>, {params?: ImagesBucketCreateParams}> = (props) => {
          const {params} = props ?? {};

          return  imagesBucketCreate(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesBucketCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesBucketCreate>>>
    
    export type ImagesBucketCreateMutationError = unknown

    export const useImagesBucketCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesBucketCreate>>, TError,{params?: ImagesBucketCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesBucketCreate>>,
        TError,
        {params?: ImagesBucketCreateParams},
        TContext
      > => {

      const mutationOptions = getImagesBucketCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesBulkUpdateUpdate = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/images/bulk_update/`, method: 'PUT'
    },
      options);
    }
  


export const getImagesBulkUpdateUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesBulkUpdateUpdate>>, TError,void, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesBulkUpdateUpdate>>, TError,void, TContext> => {

const mutationKey = ['imagesBulkUpdateUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesBulkUpdateUpdate>>, void> = () => {
          

          return  imagesBulkUpdateUpdate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesBulkUpdateUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesBulkUpdateUpdate>>>
    
    export type ImagesBulkUpdateUpdateMutationError = unknown

    export const useImagesBulkUpdateUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesBulkUpdateUpdate>>, TError,void, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesBulkUpdateUpdate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getImagesBulkUpdateUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesCountRetrieve = (
    params?: ImagesCountRetrieveParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Count>(
      {url: `/api/images/count/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getImagesCountRetrieveQueryKey = (params?: ImagesCountRetrieveParams,) => {
    return [`/api/images/count/`, ...(params ? [params]: [])] as const;
    }

    
export const getImagesCountRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof imagesCountRetrieve>>, TError = unknown>(params?: ImagesCountRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesCountRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesCountRetrieve>>> = ({ signal }) => imagesCountRetrieve(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesCountRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesCountRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof imagesCountRetrieve>>>
export type ImagesCountRetrieveQueryError = unknown


export function useImagesCountRetrieve<TData = Awaited<ReturnType<typeof imagesCountRetrieve>>, TError = unknown>(
 params: undefined |  ImagesCountRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesCountRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesCountRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesCountRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesCountRetrieve<TData = Awaited<ReturnType<typeof imagesCountRetrieve>>, TError = unknown>(
 params?: ImagesCountRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesCountRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesCountRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesCountRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesCountRetrieve<TData = Awaited<ReturnType<typeof imagesCountRetrieve>>, TError = unknown>(
 params?: ImagesCountRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesCountRetrieve<TData = Awaited<ReturnType<typeof imagesCountRetrieve>>, TError = unknown>(
 params?: ImagesCountRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesCountRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesCountRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesRandomRetrieve = (
    params?: ImagesRandomRetrieveParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PaginatedOSImage>(
      {url: `/api/images/random/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getImagesRandomRetrieveQueryKey = (params?: ImagesRandomRetrieveParams,) => {
    return [`/api/images/random/`, ...(params ? [params]: [])] as const;
    }

    
export const getImagesRandomRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError = unknown>(params?: ImagesRandomRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getImagesRandomRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof imagesRandomRetrieve>>> = ({ signal }) => imagesRandomRetrieve(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ImagesRandomRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof imagesRandomRetrieve>>>
export type ImagesRandomRetrieveQueryError = unknown


export function useImagesRandomRetrieve<TData = Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError = unknown>(
 params: undefined |  ImagesRandomRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesRandomRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesRandomRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesRandomRetrieve<TData = Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError = unknown>(
 params?: ImagesRandomRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof imagesRandomRetrieve>>,
          TError,
          Awaited<ReturnType<typeof imagesRandomRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useImagesRandomRetrieve<TData = Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError = unknown>(
 params?: ImagesRandomRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useImagesRandomRetrieve<TData = Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError = unknown>(
 params?: ImagesRandomRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof imagesRandomRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getImagesRandomRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const imagesSimilarToFileCreate = (
    imagesSimilarToFileCreateBody: ImagesSimilarToFileCreateBody,
    params?: ImagesSimilarToFileCreateParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`image`, imagesSimilarToFileCreateBody.image)
if(imagesSimilarToFileCreateBody.json !== undefined) {
 formData.append(`json`, imagesSimilarToFileCreateBody.json)
 }

      return axiosInstance<SimilarOSImage[]>(
      {url: `/api/images/similar_to_file/`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      options);
    }
  


export const getImagesSimilarToFileCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToFileCreate>>, TError,{data: ImagesSimilarToFileCreateBody;params?: ImagesSimilarToFileCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToFileCreate>>, TError,{data: ImagesSimilarToFileCreateBody;params?: ImagesSimilarToFileCreateParams}, TContext> => {

const mutationKey = ['imagesSimilarToFileCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesSimilarToFileCreate>>, {data: ImagesSimilarToFileCreateBody;params?: ImagesSimilarToFileCreateParams}> = (props) => {
          const {data,params} = props ?? {};

          return  imagesSimilarToFileCreate(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesSimilarToFileCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesSimilarToFileCreate>>>
    export type ImagesSimilarToFileCreateMutationBody = ImagesSimilarToFileCreateBody
    export type ImagesSimilarToFileCreateMutationError = unknown

    export const useImagesSimilarToFileCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToFileCreate>>, TError,{data: ImagesSimilarToFileCreateBody;params?: ImagesSimilarToFileCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesSimilarToFileCreate>>,
        TError,
        {data: ImagesSimilarToFileCreateBody;params?: ImagesSimilarToFileCreateParams},
        TContext
      > => {

      const mutationOptions = getImagesSimilarToFileCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesSimilarToTextCreate = (
    similarToText: SimilarToText,
    params?: ImagesSimilarToTextCreateParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SimilarOSImage[]>(
      {url: `/api/images/similar_to_text/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: similarToText,
        params, signal
    },
      options);
    }
  


export const getImagesSimilarToTextCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToTextCreate>>, TError,{data: SimilarToText;params?: ImagesSimilarToTextCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToTextCreate>>, TError,{data: SimilarToText;params?: ImagesSimilarToTextCreateParams}, TContext> => {

const mutationKey = ['imagesSimilarToTextCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesSimilarToTextCreate>>, {data: SimilarToText;params?: ImagesSimilarToTextCreateParams}> = (props) => {
          const {data,params} = props ?? {};

          return  imagesSimilarToTextCreate(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesSimilarToTextCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesSimilarToTextCreate>>>
    export type ImagesSimilarToTextCreateMutationBody = SimilarToText
    export type ImagesSimilarToTextCreateMutationError = unknown

    export const useImagesSimilarToTextCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToTextCreate>>, TError,{data: SimilarToText;params?: ImagesSimilarToTextCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesSimilarToTextCreate>>,
        TError,
        {data: SimilarToText;params?: ImagesSimilarToTextCreateParams},
        TContext
      > => {

      const mutationOptions = getImagesSimilarToTextCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const imagesSimilarToVectorCreate = (
    similarToVector: SimilarToVector,
    params?: ImagesSimilarToVectorCreateParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SimilarOSImage[]>(
      {url: `/api/images/similar_to_vector/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: similarToVector,
        params, signal
    },
      options);
    }
  


export const getImagesSimilarToVectorCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToVectorCreate>>, TError,{data: SimilarToVector;params?: ImagesSimilarToVectorCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToVectorCreate>>, TError,{data: SimilarToVector;params?: ImagesSimilarToVectorCreateParams}, TContext> => {

const mutationKey = ['imagesSimilarToVectorCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof imagesSimilarToVectorCreate>>, {data: SimilarToVector;params?: ImagesSimilarToVectorCreateParams}> = (props) => {
          const {data,params} = props ?? {};

          return  imagesSimilarToVectorCreate(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImagesSimilarToVectorCreateMutationResult = NonNullable<Awaited<ReturnType<typeof imagesSimilarToVectorCreate>>>
    export type ImagesSimilarToVectorCreateMutationBody = SimilarToVector
    export type ImagesSimilarToVectorCreateMutationError = unknown

    export const useImagesSimilarToVectorCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof imagesSimilarToVectorCreate>>, TError,{data: SimilarToVector;params?: ImagesSimilarToVectorCreateParams}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof imagesSimilarToVectorCreate>>,
        TError,
        {data: SimilarToVector;params?: ImagesSimilarToVectorCreateParams},
        TContext
      > => {

      const mutationOptions = getImagesSimilarToVectorCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const opensearchRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/opensearch/`, method: 'GET', signal
    },
      options);
    }
  

export const getOpensearchRetrieveQueryKey = () => {
    return [`/api/opensearch/`] as const;
    }

    
export const getOpensearchRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof opensearchRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOpensearchRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof opensearchRetrieve>>> = ({ signal }) => opensearchRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OpensearchRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof opensearchRetrieve>>>
export type OpensearchRetrieveQueryError = unknown


export function useOpensearchRetrieve<TData = Awaited<ReturnType<typeof opensearchRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof opensearchRetrieve>>,
          TError,
          Awaited<ReturnType<typeof opensearchRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpensearchRetrieve<TData = Awaited<ReturnType<typeof opensearchRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof opensearchRetrieve>>,
          TError,
          Awaited<ReturnType<typeof opensearchRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpensearchRetrieve<TData = Awaited<ReturnType<typeof opensearchRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOpensearchRetrieve<TData = Awaited<ReturnType<typeof opensearchRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOpensearchRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const opensearchRetrieve2 = (
    path: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/opensearch/${path}/`, method: 'GET', signal
    },
      options);
    }
  

export const getOpensearchRetrieve2QueryKey = (path?: string,) => {
    return [`/api/opensearch/${path}/`] as const;
    }

    
export const getOpensearchRetrieve2QueryOptions = <TData = Awaited<ReturnType<typeof opensearchRetrieve2>>, TError = unknown>(path: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOpensearchRetrieve2QueryKey(path);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof opensearchRetrieve2>>> = ({ signal }) => opensearchRetrieve2(path, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(path),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OpensearchRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof opensearchRetrieve2>>>
export type OpensearchRetrieve2QueryError = unknown


export function useOpensearchRetrieve2<TData = Awaited<ReturnType<typeof opensearchRetrieve2>>, TError = unknown>(
 path: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof opensearchRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof opensearchRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpensearchRetrieve2<TData = Awaited<ReturnType<typeof opensearchRetrieve2>>, TError = unknown>(
 path: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof opensearchRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof opensearchRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOpensearchRetrieve2<TData = Awaited<ReturnType<typeof opensearchRetrieve2>>, TError = unknown>(
 path: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOpensearchRetrieve2<TData = Awaited<ReturnType<typeof opensearchRetrieve2>>, TError = unknown>(
 path: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof opensearchRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOpensearchRetrieve2QueryOptions(path,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<null>(
      {url: `/api/stats/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsRetrieveQueryKey = () => {
    return [`/api/stats/`] as const;
    }

    
export const getStatsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof statsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsRetrieve>>> = ({ signal }) => statsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof statsRetrieve>>>
export type StatsRetrieveQueryError = unknown


export function useStatsRetrieve<TData = Awaited<ReturnType<typeof statsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsRetrieve<TData = Awaited<ReturnType<typeof statsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsRetrieve<TData = Awaited<ReturnType<typeof statsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsRetrieve<TData = Awaited<ReturnType<typeof statsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsAttributesList = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<AttributeField[]>(
      {url: `/api/stats/attributes/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsAttributesListQueryKey = () => {
    return [`/api/stats/attributes/`] as const;
    }

    
export const getStatsAttributesListQueryOptions = <TData = Awaited<ReturnType<typeof statsAttributesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsAttributesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsAttributesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsAttributesList>>> = ({ signal }) => statsAttributesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsAttributesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsAttributesListQueryResult = NonNullable<Awaited<ReturnType<typeof statsAttributesList>>>
export type StatsAttributesListQueryError = unknown


export function useStatsAttributesList<TData = Awaited<ReturnType<typeof statsAttributesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsAttributesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsAttributesList>>,
          TError,
          Awaited<ReturnType<typeof statsAttributesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsAttributesList<TData = Awaited<ReturnType<typeof statsAttributesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsAttributesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsAttributesList>>,
          TError,
          Awaited<ReturnType<typeof statsAttributesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsAttributesList<TData = Awaited<ReturnType<typeof statsAttributesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsAttributesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsAttributesList<TData = Awaited<ReturnType<typeof statsAttributesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsAttributesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsAttributesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsImageAspectRatioFractionsRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<StatsImageAspectRatioFractionsRetrieve200>(
      {url: `/api/stats/image_aspect_ratio_fractions/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsImageAspectRatioFractionsRetrieveQueryKey = () => {
    return [`/api/stats/image_aspect_ratio_fractions/`] as const;
    }

    
export const getStatsImageAspectRatioFractionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsImageAspectRatioFractionsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>> = ({ signal }) => statsImageAspectRatioFractionsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsImageAspectRatioFractionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>>
export type StatsImageAspectRatioFractionsRetrieveQueryError = unknown


export function useStatsImageAspectRatioFractionsRetrieve<TData = Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsImageAspectRatioFractionsRetrieve<TData = Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsImageAspectRatioFractionsRetrieve<TData = Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsImageAspectRatioFractionsRetrieve<TData = Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageAspectRatioFractionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsImageAspectRatioFractionsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsImageSourcesRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<StatsImageSourcesRetrieve200>(
      {url: `/api/stats/image_sources/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsImageSourcesRetrieveQueryKey = () => {
    return [`/api/stats/image_sources/`] as const;
    }

    
export const getStatsImageSourcesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsImageSourcesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>> = ({ signal }) => statsImageSourcesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsImageSourcesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>>
export type StatsImageSourcesRetrieveQueryError = unknown


export function useStatsImageSourcesRetrieve<TData = Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsImageSourcesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsImageSourcesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsImageSourcesRetrieve<TData = Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsImageSourcesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsImageSourcesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsImageSourcesRetrieve<TData = Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsImageSourcesRetrieve<TData = Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImageSourcesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsImageSourcesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsLatentTypesList = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<LatentType[]>(
      {url: `/api/stats/latent_types/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsLatentTypesListQueryKey = () => {
    return [`/api/stats/latent_types/`] as const;
    }

    
export const getStatsLatentTypesListQueryOptions = <TData = Awaited<ReturnType<typeof statsLatentTypesList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsLatentTypesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsLatentTypesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsLatentTypesList>>> = ({ signal }) => statsLatentTypesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsLatentTypesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsLatentTypesListQueryResult = NonNullable<Awaited<ReturnType<typeof statsLatentTypesList>>>
export type StatsLatentTypesListQueryError = unknown


export function useStatsLatentTypesList<TData = Awaited<ReturnType<typeof statsLatentTypesList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsLatentTypesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsLatentTypesList>>,
          TError,
          Awaited<ReturnType<typeof statsLatentTypesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsLatentTypesList<TData = Awaited<ReturnType<typeof statsLatentTypesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsLatentTypesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsLatentTypesList>>,
          TError,
          Awaited<ReturnType<typeof statsLatentTypesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsLatentTypesList<TData = Awaited<ReturnType<typeof statsLatentTypesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsLatentTypesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsLatentTypesList<TData = Awaited<ReturnType<typeof statsLatentTypesList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsLatentTypesList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsLatentTypesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsQueueRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Queue>(
      {url: `/api/stats/queue/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsQueueRetrieveQueryKey = () => {
    return [`/api/stats/queue/`] as const;
    }

    
export const getStatsQueueRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof statsQueueRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsQueueRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsQueueRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsQueueRetrieve>>> = ({ signal }) => statsQueueRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsQueueRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsQueueRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof statsQueueRetrieve>>>
export type StatsQueueRetrieveQueryError = unknown


export function useStatsQueueRetrieve<TData = Awaited<ReturnType<typeof statsQueueRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsQueueRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsQueueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsQueueRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsQueueRetrieve<TData = Awaited<ReturnType<typeof statsQueueRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsQueueRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsQueueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsQueueRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsQueueRetrieve<TData = Awaited<ReturnType<typeof statsQueueRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsQueueRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsQueueRetrieve<TData = Awaited<ReturnType<typeof statsQueueRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsQueueRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsQueueRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const statsTotalsRetrieve = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Totals>(
      {url: `/api/stats/totals/`, method: 'GET', signal
    },
      options);
    }
  

export const getStatsTotalsRetrieveQueryKey = () => {
    return [`/api/stats/totals/`] as const;
    }

    
export const getStatsTotalsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStatsTotalsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsTotalsRetrieve>>> = ({ signal }) => statsTotalsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StatsTotalsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof statsTotalsRetrieve>>>
export type StatsTotalsRetrieveQueryError = unknown


export function useStatsTotalsRetrieve<TData = Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsTotalsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsTotalsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsTotalsRetrieve<TData = Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof statsTotalsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof statsTotalsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStatsTotalsRetrieve<TData = Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useStatsTotalsRetrieve<TData = Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsTotalsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsTotalsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsList = (
    params?: TagsListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PaginatedTagList>(
      {url: `/api/tags/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTagsListQueryKey = (params?: TagsListParams,) => {
    return [`/api/tags/`, ...(params ? [params]: [])] as const;
    }

    
export const getTagsListQueryOptions = <TData = Awaited<ReturnType<typeof tagsList>>, TError = unknown>(params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsList>>> = ({ signal }) => tagsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TagsListQueryResult = NonNullable<Awaited<ReturnType<typeof tagsList>>>
export type TagsListQueryError = unknown


export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = unknown>(
 params: undefined |  TagsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsList>>,
          TError,
          Awaited<ReturnType<typeof tagsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = unknown>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsList>>,
          TError,
          Awaited<ReturnType<typeof tagsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = unknown>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = unknown>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTagsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsCreate = (
    tag: NonReadonly<Tag>,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Tag>(
      {url: `/api/tags/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tag, signal
    },
      options);
    }
  


export const getTagsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext> => {

const mutationKey = ['tagsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsCreate>>, {data: NonReadonly<Tag>}> = (props) => {
          const {data} = props ?? {};

          return  tagsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsCreate>>>
    export type TagsCreateMutationBody = NonReadonly<Tag>
    export type TagsCreateMutationError = unknown

    export const useTagsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsCreate>>,
        TError,
        {data: NonReadonly<Tag>},
        TContext
      > => {

      const mutationOptions = getTagsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tagsRetrieve = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Tag>(
      {url: `/api/tags/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTagsRetrieveQueryKey = (id?: string,) => {
    return [`/api/tags/${id}/`] as const;
    }

    
export const getTagsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsRetrieve>>> = ({ signal }) => tagsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TagsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tagsRetrieve>>>
export type TagsRetrieveQueryError = unknown


export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tagsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tagsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTagsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsUpdate = (
    id: string,
    tag: NonReadonly<Tag>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<Tag>(
      {url: `/api/tags/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: tag
    },
      options);
    }
  


export const getTagsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: string;data: NonReadonly<Tag>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: string;data: NonReadonly<Tag>}, TContext> => {

const mutationKey = ['tagsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsUpdate>>, {id: string;data: NonReadonly<Tag>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsUpdate>>>
    export type TagsUpdateMutationBody = NonReadonly<Tag>
    export type TagsUpdateMutationError = unknown

    export const useTagsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: string;data: NonReadonly<Tag>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsUpdate>>,
        TError,
        {id: string;data: NonReadonly<Tag>},
        TContext
      > => {

      const mutationOptions = getTagsUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tagsPartialUpdate = (
    id: string,
    patchedTag: NonReadonly<PatchedTag>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<Tag>(
      {url: `/api/tags/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedTag
    },
      options);
    }
  


export const getTagsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedTag>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedTag>}, TContext> => {

const mutationKey = ['tagsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsPartialUpdate>>, {id: string;data: NonReadonly<PatchedTag>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsPartialUpdate>>>
    export type TagsPartialUpdateMutationBody = NonReadonly<PatchedTag>
    export type TagsPartialUpdateMutationError = unknown

    export const useTagsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedTag>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsPartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedTag>},
        TContext
      > => {

      const mutationOptions = getTagsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tagsDestroy = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/tags/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getTagsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['tagsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  tagsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof tagsDestroy>>>
    
    export type TagsDestroyMutationError = unknown

    export const useTagsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTagsDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tagsTagImagesUpdate = (
    imageIdsWithTagNames: ImageIdsWithTagNames,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<TagImagesResponse>(
      {url: `/api/tags/tag_images/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: imageIdsWithTagNames
    },
      options);
    }
  


export const getTagsTagImagesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsTagImagesUpdate>>, TError,{data: ImageIdsWithTagNames}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tagsTagImagesUpdate>>, TError,{data: ImageIdsWithTagNames}, TContext> => {

const mutationKey = ['tagsTagImagesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsTagImagesUpdate>>, {data: ImageIdsWithTagNames}> = (props) => {
          const {data} = props ?? {};

          return  tagsTagImagesUpdate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsTagImagesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsTagImagesUpdate>>>
    export type TagsTagImagesUpdateMutationBody = ImageIdsWithTagNames
    export type TagsTagImagesUpdateMutationError = unknown

    export const useTagsTagImagesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsTagImagesUpdate>>, TError,{data: ImageIdsWithTagNames}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsTagImagesUpdate>>,
        TError,
        {data: ImageIdsWithTagNames},
        TContext
      > => {

      const mutationOptions = getTagsTagImagesUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tokensList = (
    params?: TokensListParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PaginatedTokenList>(
      {url: `/api/tokens/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTokensListQueryKey = (params?: TokensListParams,) => {
    return [`/api/tokens/`, ...(params ? [params]: [])] as const;
    }

    
export const getTokensListQueryOptions = <TData = Awaited<ReturnType<typeof tokensList>>, TError = unknown>(params?: TokensListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTokensListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tokensList>>> = ({ signal }) => tokensList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tokensList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TokensListQueryResult = NonNullable<Awaited<ReturnType<typeof tokensList>>>
export type TokensListQueryError = unknown


export function useTokensList<TData = Awaited<ReturnType<typeof tokensList>>, TError = unknown>(
 params: undefined |  TokensListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tokensList>>,
          TError,
          Awaited<ReturnType<typeof tokensList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTokensList<TData = Awaited<ReturnType<typeof tokensList>>, TError = unknown>(
 params?: TokensListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tokensList>>,
          TError,
          Awaited<ReturnType<typeof tokensList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTokensList<TData = Awaited<ReturnType<typeof tokensList>>, TError = unknown>(
 params?: TokensListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTokensList<TData = Awaited<ReturnType<typeof tokensList>>, TError = unknown>(
 params?: TokensListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensList>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTokensListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tokensCreate = (
    token: NonReadonly<Token>,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Token>(
      {url: `/api/tokens/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: token, signal
    },
      options);
    }
  


export const getTokensCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensCreate>>, TError,{data: NonReadonly<Token>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokensCreate>>, TError,{data: NonReadonly<Token>}, TContext> => {

const mutationKey = ['tokensCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokensCreate>>, {data: NonReadonly<Token>}> = (props) => {
          const {data} = props ?? {};

          return  tokensCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokensCreateMutationResult = NonNullable<Awaited<ReturnType<typeof tokensCreate>>>
    export type TokensCreateMutationBody = NonReadonly<Token>
    export type TokensCreateMutationError = unknown

    export const useTokensCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensCreate>>, TError,{data: NonReadonly<Token>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tokensCreate>>,
        TError,
        {data: NonReadonly<Token>},
        TContext
      > => {

      const mutationOptions = getTokensCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tokensRetrieve = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<Token>(
      {url: `/api/tokens/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getTokensRetrieveQueryKey = (id?: string,) => {
    return [`/api/tokens/${id}/`] as const;
    }

    
export const getTokensRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof tokensRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTokensRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tokensRetrieve>>> = ({ signal }) => tokensRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id),  retry: (failureCount, error) => {
              // Type guard for axios error
              if (error && typeof error === 'object' && 'response' in error && error.response && typeof error.response === 'object' && 'status' in error.response) {
                const status = error.response.status;
                if (status === 404 || status === 403) {
                  // Fail fast on 404 and 403
                  return false;
                }
              }
              return failureCount < 2;
            },  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tokensRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TokensRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tokensRetrieve>>>
export type TokensRetrieveQueryError = unknown


export function useTokensRetrieve<TData = Awaited<ReturnType<typeof tokensRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tokensRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tokensRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTokensRetrieve<TData = Awaited<ReturnType<typeof tokensRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tokensRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tokensRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTokensRetrieve<TData = Awaited<ReturnType<typeof tokensRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTokensRetrieve<TData = Awaited<ReturnType<typeof tokensRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tokensRetrieve>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTokensRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tokensUpdate = (
    id: string,
    token: NonReadonly<Token>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<Token>(
      {url: `/api/tokens/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: token
    },
      options);
    }
  


export const getTokensUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensUpdate>>, TError,{id: string;data: NonReadonly<Token>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokensUpdate>>, TError,{id: string;data: NonReadonly<Token>}, TContext> => {

const mutationKey = ['tokensUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokensUpdate>>, {id: string;data: NonReadonly<Token>}> = (props) => {
          const {id,data} = props ?? {};

          return  tokensUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokensUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tokensUpdate>>>
    export type TokensUpdateMutationBody = NonReadonly<Token>
    export type TokensUpdateMutationError = unknown

    export const useTokensUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensUpdate>>, TError,{id: string;data: NonReadonly<Token>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tokensUpdate>>,
        TError,
        {id: string;data: NonReadonly<Token>},
        TContext
      > => {

      const mutationOptions = getTokensUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tokensPartialUpdate = (
    id: string,
    patchedToken: NonReadonly<PatchedToken>,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<Token>(
      {url: `/api/tokens/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedToken
    },
      options);
    }
  


export const getTokensPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedToken>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokensPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedToken>}, TContext> => {

const mutationKey = ['tokensPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokensPartialUpdate>>, {id: string;data: NonReadonly<PatchedToken>}> = (props) => {
          const {id,data} = props ?? {};

          return  tokensPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokensPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tokensPartialUpdate>>>
    export type TokensPartialUpdateMutationBody = NonReadonly<PatchedToken>
    export type TokensPartialUpdateMutationError = unknown

    export const useTokensPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensPartialUpdate>>, TError,{id: string;data: NonReadonly<PatchedToken>}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tokensPartialUpdate>>,
        TError,
        {id: string;data: NonReadonly<PatchedToken>},
        TContext
      > => {

      const mutationOptions = getTokensPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tokensDestroy = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      
      
      return axiosInstance<null>(
      {url: `/api/tokens/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getTokensDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokensDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['tokensDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokensDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  tokensDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokensDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof tokensDestroy>>>
    
    export type TokensDestroyMutationError = unknown

    export const useTokensDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokensDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tokensDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTokensDestroyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
